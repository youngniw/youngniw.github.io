---
layout: post
toc: true
title: "[자료구조] 그래프1"
categories: 자료구조
tags: 자료구조, 그래프
---

<h2>그래프 개념 및 정의, 그래프의 탐색(깊이 우선 탐색, 너비 우선 탐색)</h2>

## 0. 들어가기에 앞서..
현재 이 포스트는 생능출판의 "C언어로 쉽게 풀어쓴 자료구조(개정3판)"에 대한 내용을 바탕으로 작성하였습니다. 

자료구조는 대학교 2학년 1학기에 배우고 공부를 하게 되었는데, 3년이 지난 지금 기억이 나지 않는 부분이 있어서 다시 공부하게 되었다. 
특히 이 그래프 부분은 용어들과 알고리즘들을 기억해야 된다고 생각했기에 이 포스트를 작성하게 되었다.

<br/>
<hr/>

## 10.1 그래프란?
<h4>[ 그래프의 소개 ]</h4>

<b>그래프(Graph)</b>: 객체 사이의 연결 관계를 표현할 수 있는 자료 구조

그래프 구조는 인접 행렬이나 인접 리스트로 메모리에 표현되고 처리될 수 있으므로 광범위한 분야의 다양한 문제들을 그래프로 표현하여 컴퓨터 프로그래밍에 의해 해결할 수 있다.

또한 그래프는 아주 일반적인 자료 구조로서 트리도 그래프의 하나의 특수한 종류로 볼 수 있다.
<br/><br/>


<h4>[ 그래프의 역사 ]</h4>

"Konigsberg의 다리" 문제: "임의의 지역에서 출발하여 모든 다리를 단 한번만 건너서 처음 출발했던 지역으로 돌아올 수 있는가"

->오일러는 특정 지역은 정점(node)로, 다리는 간선(edge)로 표현하여 그래프 문제로 변환하여 생각함

<b>오일러 경로(Eulerian tour):</b> 그래프에 존재하는 모든 간선을 한번만 통과하면서 처음 정점으로 되돌아오는 경로<br/>
<b>오일러 정리:</b> 그래프의 모든 정점에 연결된 간선의 개수가 짝수일 때만 오일러 경로가 존재한다.

<br/>
<hr/>

## 10.2 그래프의 정의와 용어
<h4>[ 그래프의 정의 ]</h4>

<b>그래프:</b> 정점<sup>vertex</sup>와 간선<sup>edge</sup>들의 유한 집합

    수학적 기호: G = (V, E)
    이때 V(G): 그래프 G의 정점들의 집합, E(G): 그래프 G의 간선들의 집합

<b>정점:</b> 여러 가지 특성을 가질 수 있는 객체 (=노드<sup>node</sup>)

<b>간선:</b> 정점들 간의 관계 (=링크<sup>link</sup>)
<br/><br/>


<h4>[ 무방향 그래프와 방향 그래프 ]</h4>

그래프는 간선의 종류에 따라 <b>무방향 그래프</b>와 <b>방향 그래프</b>로 구분된다.

<b>무방향 그래프<sup>undirected graph</sup>:</b> 그래프의 간선은 간선<sup>-</sup>을 통해서 양방향으로 갈 수 있음<br/>
-> 정점 A와 정점 B를 연결하는 간선은 (A, B)와 같이 정점의 쌍으로 표현&nbsp;&nbsp;<span style="color:blue">(A,B) = (B,A)</span>

<b>방향 그래프<sup>directed graph</sup>:</b> 간선<sup>-></sup>에 방향성이 존재하는 그래프<br/>
-> 정점 A와 정점 B로만 갈 수 있는 간선은 &lt;A, B&gt;로 표시&nbsp;&nbsp;<span style="color:blue">&lt;A,B&gt; &#8800; &lt;B,A&gt;</span>
<br/><br/>


<h4>[ 네트워크 ]</h4>

<b>가중치 그래프<sup>weighted graph</sup>:</b> 간선에 비용이나 가중치가 할당된 그래프 (= 네트워크<sup>network</sup>)
<br/><br/>


<h4>[ 부분 그래프 ]</h4>

<b>부분 그래프<sup>subgraph</sup>:</b> 어떤 그래프의 정점의 일부와 간선의 일부로 이루어진 그래프

    그래프 G의 부분 그래프 S일 때,
    
     V(S) ⊆ V(G)
     E(S) ⊆ E(G)
<br/>


<h4>[ 정점의 차수 ]</h4>

그래프에서의 <b>인접 정점<sup>adjacent vertex</sup>:</b> 간선에 의해 직접 연결된 정점

1. <u>무방향 그래프</u>에서 정점의 차수(degree): 그 정점에 인접한 정점의 수<br/>
-> 모든 정점의 차수를 합하면 간선 수의 2배가 됨
2. <u>방향 그래프</u>에서는 외부에서 오는 간선의 개수를 <b>진입 차수<sup>in-degree</sup></b>라고 하고, 외부로 향하는 간선의 개수를 <b>진출 차수<sup>out-degree</sup></b>라고 함
<br/><br/>


<h4>[ 경로 ]</h4>

무방향 그래프에서 정점 s로부터 정점 e까지의 경로는 정점의 나열 s, v<sub>1</sub>, v<sub>2</sub>, ... , v<sub>k</sub>, e로서, 나열된 정점들 간에는 반드시 간선 (s, v<sub>1</sub>), (v<sub>1</sub>, v<sub>2</sub>), ... , (v<sub>k</sub>, e)가 있어야 한다.

방향 그래프라면 나열된 정점들 간에는 반드시 간선 &lt;s, v<sub>1</sub>&gt;, &lt;v<sub>1</sub>, v<sub>2</sub>&gt;, ... , &lt;v<sub>k</sub>, e&gt;가 있어야 한다.

<b>단순 경로<sup>simple path</sup>:</b> 경로 중에서 반복되는 간선이 없을 경우일 때의 경로

<b>사이클<sup>cycle</sup>:</b> 단순 경로의 시작 정점과 종료 정점이 동일할 때의 경로
<br/><br/>


<h4>[ 연결 그래프 ]</h4>

무방향 그래프에서의 <b>연결 그래프<sup>connected graph</sup>:</b> 무방향 그래프 G에 있는 모든 정점쌍에 대해 항상 경로가 존재함 (= G는 연결됨) <br/>
<-> 비연결 그래프

Ex. 트리는 그래프의 특수한 형태로서 사이클을 가지지 않는 연결 그래프

*&nbsp;참고<br/> 
강력 연결 그래프: 모든 쌍의 정점들 사이에 상호방향 경로(양방향 모두)가 존재<br/>
강력 연결 요소: 방향성이 존재하는 유향 그래프에서 모든 정점이 다른 모든 정점들에 대하여 방문할 수 있는 경우 즉, 어떤 두 정점 간의 경로가 존재
<br/><br/>


<h4>[ 완전 그래프 ]</h4>

<img src="https://upload.wikimedia.org/wikipedia/commons/thumb/5/59/Complete_graph_K4.svg/180px-Complete_graph_K4.svg.png" width="120" height="120"/> &nbsp;&nbsp;&nbsp;
<img src="https://upload.wikimedia.org/wikipedia/commons/thumb/c/cf/Complete_graph_K5.svg/180px-Complete_graph_K5.svg.png" width="120" height="120"/>

<b>완전 그래프<sup>complete graph</sup>:</b> 그래프에 속해있는 모든 정점이 서로 연결되어 있는 그래프

무방향 완전 그래프의 정점 수를 n이라고 할 때, 하나의 정점은 n-1개의 다른 정점으로 연결되므로 간선의 수는 n × (n-1) / 2가 된다.

<br/>
<hr/>

## 10.3 그래프의 표현 방법
그래프를 표현하는 방법에는 다음의 2가지 방법이 있다.

- <b>인접 행렬<sup>adjacent matrix</sup>:</b> 2차원 배열을 사용해 그래프를 표현
- <b>인접 리스트<sup>adjacent list</sup>:</b> 연결 리스트를 사용해 그래프를 표현

따라서 문제의 특성에 따라 적합한 표현 방법을 선택해야 한다.

<h4>[ 인접 행렬 ]</h4>

그래프의 정점 수가 n이라면 n × n의 2차원 배열인 인접 행렬 M의 각 원소를 다음의 규칙에 의해 할당함으로써 그래프를 메모리에 표현할 수 있다.
    
    if (간선 (i, j)가 그래프에 존재)
        M[i][j] = 1
    otherwise
        M[i][j] = 0

n개의 정점을 가지는 그래프를 인접 행렬로 표현하기 위해서는 간선의 수에 무관하게 항상 n<sup>2</sup>개의 메모리 공간이 필요하다.<br/>
-> 인접 행렬은 밀집 그래프<sup>dense graph</sup>를 표현하는 경우에 적합하지만, 희소 그래프<sup>sparse graph</sup>의 경우에는 메모리 낭비가 크므로 적합하지 않다.

- 두 정점을 연결하는 간선의 존재 여부 소요 시간: O(1)
- 정점의 차수 검색 소요 시간: O(n)<br/>
    (정점 i에 대한 차수 = 인접 배열의 i번째 행에 있는 값을 모두 더한 값)
- 그래프 내의 모든 간선의 수: O(n<sup>2</sup>) -> 인접 행렬 전체를 조사
<br/><br/>


<h4>[ 인접 리스트 ]</h4>

<b>인접 리스트:</b> 그래프를 표현함에 있어 각각의 정점에 인접한 정점들을 연결 리스트로 표시한 것

각 연결리스트들은 헤더 노드를 가지고 있고 이 헤더 노드들은 하나의 배열로 구성되어 있다. 
따라서 정점의 번호만 알면 이 번호를 배열의 인덱스로 하여 각 정점의 연결 리스트에 쉽게 접근할 수 있다.

정점의 개수가 n개이고 간선의 수가 e개인 무방향 그래프를 표시하기 위해서는 n개의 연결 리스트가 필요하고, n개의 헤더 노드와 2e개의 노드가 필요하다.
따라서 인접 리스트 표현은 간선의 개수가 적은 희소 그래프의 표현에 적합하다.

n개 정점과 e개의 간선을 가진 그래프에서 <br/>
전체 간선의 수 조회 소요시간: O(n+e) -> 헤더 노드를 포함하여 모든 인접 리스트를 조사
<br/><br/>


<h4>[ 인접 리스트를 이용한 그래프 추상 데이터 타입의 구현 ]</h4>

다음은 인접 리스트를 이용한 그래프에서의 간선 삽입 연산 코드이다. <br/>
```c
#define MAX_VERTICES 50
typedef struct GraphNode {
    int vertex;
    struct GraphNode* link;
} GraphNode;

typedef struct GraphType {
    int n;  //정점의 개수
    GraphNode* adj_list[MAX_VERTICES];
} GraphType;


//v(정점)를 u(정점)의 인접 리스트에 삽입한다.
void insert_edge(GraphType* g, int u, int v)
{
    GraphNode* node;
    if (u >= g->n || v >= g->n) {
        fprintf(stderr, "그래프: 정점 번호 오류")
    }
 
    node = (GraphNode*)malloc(sizeof(GraphNode));
    node->vertex = v;
    node->link = g->adj_list[u];
    g->adj_list[u] = node;
}
```
정점 u에 간선 (u, v)를 삽입하는 연산은 정점 u의 인접 리스트에 간선을 나타내는 노드를 하나 생성하여 삽입하면 된다. 
이때 위치는 상관이 없으므로 삽입을 쉽게 하기 위해 연결 리스트의 맨 처음에 삽입한다.

<br/>
<hr/>

## 10.4 그래프의 탐색
그래프 탐색: 하나의 정점으로부터 시작하여 차례대로 모든 정점들을 한 번씩 방문

그래프의 탐색 방법은 두 가지가 있다.
- 깊이 우선 탐색(DFS: depth first searching)
- 너비 우선 탐색(BFS: breadth first searching)

<b>깊이 우선 탐색:</b> 트리 탐색 시, 시작 정점에서 한 방향으로 계속 가다가 더 이상 갈 수 없게 되면 다시 가장 가까운 갈림길로 돌아와서 다른 방향으로 다시 탐색을 진행하는 방법과 유사함

<b>너비 우선 탐색:</b> 시작 정점으로부터 가까운 정점을 먼저 방문하고 멀리 떨어져 있는 정점을 나중에 방문하는 순회 방법

<br/>
<hr/>

## 10.5 깊이 우선 탐색
<img src="https://user-images.githubusercontent.com/78736070/159255580-2f769548-56da-4fbf-b642-cf3458964fe5.png" width="180" height="180"/>

깊이 우선 탐색 진행 순서
1. 그래프의 시작 정점에서 출발하여 시작 정점 v을 방문하였다고 표시함
2. v에 인접한 정점들 중에서 아직 방문하지 않은 정점 u를 선택<br/>
2-1. 만약 그러한 정점이 없다면 탐색 종료
3. 만약 아직 방문하지 않은 정점 u가 있다면 u를 시작 정점으로 하여 깊이 우선 탐색을 다시 시작
... 2~3을 반복함

따라서 깊이 우선 탐색도 자기 자신을 다시 호출하는 순환 알고리즘의 형태를 가지고 있다.

다음은 깊이 우선 탐색의 알고리즘을 수도코드로 보여준다.
```
depth_first_search(v):

    v를 방문되었다고 표시
    for all u ∈ (v에 인접한 정점) do
        if (u가 아직 방문되지 않았으면)
            then depth_first_search(u)
```

위의 코드에서는 순환을 사용하지만 명시적인 스택을 사용하여 구현도 가능하다.
```
DFS-iterative(G, v):

    스택 S를 생성한다.
    S.push(v)
    while (not is_empty(S)) do
        v = S.pop()
        if (v가 방문되지 않았다면)
            v를 방문되었다고 표시
            for all u ∈ (v에 인접한 정점) do
                if (u가 아직 방문되지 않았으면)
                    S.push(u)
```

<h4>[ 깊이 우선 탐색의 분석 ]</h4>
정점의 수가 n이고 간선의 수가 e인 그래프인 경우, <br/>
- 인접 리스트로 표현 시 시간 복잡도: O(n+e)
- 인접 행렬로 표현 시 시간 복잡도: O(n<sup>2</sup>)

<br/>
<hr/>

## 10.6 너비 우선 탐색
<img src="https://user-images.githubusercontent.com/78736070/159255762-e5856ede-53d7-4126-9182-fced2cede704.png" width="200" height="150"/>

<b>너비 우선 탐색(BFS):</b> 시작 정점으로부터 가까운 정점을 먼저 방문하고 멀리 떨어져 있는 정점을 나중에 방문하는 순회 방법

BFS를 위해서는 자료 구조인 큐<sup>queue</sup>가 필요하다.

너비 우선 탐색 진행 순서
1. 큐에서 정점을 꺼내서 정점을 방문한다.
2. 해당 정점의 인접 정점들을 큐에 추가한다.
3. 큐가 소진될 때까지 동일한 코드를 반복한다.

다음은 너비 우선 탐색의 의사 코드이다.
```
breadth_first_search(v):

    v를 방문되었다고 표시;
    큐 Q에 정점 v를 삽입;
    while (Q가 공백이 아니면) do
        Q에서 정점 v를 삭제;
        for all u ∈ (v에 인접한 정점) do
            if (u가 아직 방문되지 않았으면)
                then u를 큐에 삽입;
                    u를 방문되었다고 표시;
```

위의 코드에서는 순환을 사용하지만 명시적인 스택을 사용하여 구현도 가능하다.

<h4>[ 너비 우선 탐색의 분석 ]</h4>
- 인접 리스트로 표현 시 시간 복잡도: O(n+e)
- 인접 행렬로 표현 시 시간 복잡도: O(n<sup>2</sup>)

너비 우선 탐색도 깊이 우선 탐색과 같이 희소 그래프를 사용할 경우 인접 리스트를 사용하는 것이 효율적이다.

<br/>
<hr/>

지금까지 자료구조 중 그래프의 개념, 그리고 그래프의 탐색(BFS, DFS)을 설명하는 포스트였습니다.

다음 포스트는 최소 비용 신장 트리의 개념과 최소 비용 신장 트리를 구하는 방법으로 사용되는 Kruskal과 Prim이 제안한 알고리즘을 설명합니다.

감사합니다:)
