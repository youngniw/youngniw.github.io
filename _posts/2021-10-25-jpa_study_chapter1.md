---
layout: post
toc: true
title: "[JPA] 1. JPA 소개"
categories: JPA
tags: 스프링부트, JPA
---

# &#91;자바 ORM 표준 JPA 프로그래밍&#93; Chapter 1. JPA 소개

## 0. 들어가기에 앞서..
현재 이 포스트는 김영한님의 자바 ORM 표준 JPA 프로그래밍 책에 대한 내용을 바탕으로 작성하였습니다. 

<br/><hr/><br/>

JPA는 자바 진영의 ORM 기술 표준으로, 반복적인 CRUD(등록, 조회, 수정, 삭제) SQL을 알아서 처리해 줄 뿐만 아니라 객체 모델링과 관계형 데이터베이스 사이의 차이점도 해결해 준다. 
또한 실행 시점에 자동으로 SQL을 만들어서 실행하는데, JPA를 사용하는 개발자는 SQL을 직접 작성하는 것이 아닌 어떤 SQL이 실행될지 만을 생각하면 된다. 
이러한 JPA가 실행하는 SQL은 우리가 쉽게 예측할 수 있다.

이러한 JPA를 사용함으로써 애플리케이션을 SQL이 아닌 객체 중심으로 개발을 함으로 인해 얻게된 장점으로는 생산성과 유지보수가 좋아진 것이고, 테스트를 작성하기도 편리해진 것이다.
또한 JPA로 인해 코드를 거의 수정하지 않고도 데이터베이스를 쉽게 변경할 수 있다는 것이다.

지금부터 SQL을 직접 다룰 때 어떤 문제가 발생하는지, 그리고 객체와 관계형 데이터베이스 사이에는 어떤 차이가 있는지 설명하고자 한다.

<br/><hr/><br/>


## 1.1 SQL을 직접 다룰 때 발생하는 문제점
관계형 데이터베이스는 가장 대중적이고 신뢰할 만한 안전한 데이터 저장소다. 그래서 자바로 개발하는 애플리케이션은 대부분 관계형 데이터베이스를 데이터 저장소로 사용한다.

이때 데이터베이스에 데이터를 관리하려면 SQL을 사용해야 한다. 자바로 작성한 애플리케이션은 JDBC API를 사용해서 SQL을 데이터베이스에 전달함으로써 결과를 반환받는다.
<br/><br/>

### 1.1.1 반복, 반복 그리고 반복
SQL을 직접 다룰 때의 문제점을 알아보기 위해 자바와 관계형 데이터베이스를 사용해서 회원 관리 기능을 개발해보자. 
이때 회원 테이블은 이미 만들어져 있다고 가정하고 회원을 CRUD하는 기능을 개발해보고자 할 때, 자바에서 사용할 회원 객체는 다음과 같다.
```java
//예제 1.1 회원객체
public class Member {
    private String memberId;
    private String name;
    ···
}
```

다음으로 회원 객체를 데이터베이스에 관리할 목적으로 회원용 DAO(데이터 접근 객체)를 만든다.
```java
//예제 1.2,3 회원용 DAO
public class MemberDAO {
    public Member find(String memberId) { ... }
    public void save(Member member) { ... }
}
```

회원을 <b>조회</b>하는 기능을 만들 때 보통 다음의 순서로 개발을 진행하게 된다.
1. 회원 조회용 SQL을 작성한다.<br/>
`String sql = "SELECT member_id, name FROM MEMBER WHERE member_id = ?";`<br/><br/>

2. JDBC API를 사용해서 SQL을 실행한다.<br/>
`ResultSet rs = pstmt.executeQuery(sql);`<br/><br/>

3. 조회 결과를 Member 객체로 매핑한다.<br/>
`String memberId = rs.getString("member_id");`<br/>
`String name = rs.getString("name");`<br/>
<br/>
`Member member = new Member();`<br/>
`member.setMemberId(memberId);`<br/>
`member.setName(name);`

<br/>또한 회원을 <b>등록</b>하는 기능을 만들 때 보통 다음의 순서로 개발을 진행하게 된다.
1. 회원 등록용 SQL을 작성한다.<br/>
`String sql = "INSERT INTO MEMBER(member_id, name) VALUES(?, ?)";`<br/><br/>

2. 회원 객체의 값을 꺼내서 등록 SQL에 전달한다.<br/>
`pstmt.setString(1, member.getMemberId())`<br/>
`pstmt.setString(2, member.getName())`<br/><br/>

3. JDBC API를 사용해서 SQL을 실행한다.<br/>
`stmt.updateQuery(sql);`

<br/>위와 달리, 객체를 데이터베이스가 아닌 자바 컬렉션에 보관을 한다면 add()메소드를 통해 한 줄로 객체를 저장할 수 있다.

하지만 데이터베이스는 객체 구조와는 다른 데이터 중심의 구조를 가지므로 객체를 데이터베이스에 직접 저장하거나 조회할 수는 없다. 
따라서 개발자가 객체지향 애플리케이션과 데이터베이스 중간에서 SQL과 JDBC API를 사용해서 변환 작업을 직접해줘야 한다.

문제는 객체를 데이터베이스에 CRUD를 하려면 너무 많은 SQL과 JDBC API 코드를 작성해야 한다는 것이다. 
그리고 애플리케이션에서 사용하는 데이터베이스 테이블이 많다면 이에 배로 많은 SQL을 작성해야 하고 비슷한 일을 반복해야 한다.
<br/><br/>

### 1.1.2 SQL에 의존적인 개발
만약 회원의 연락처도 함께 저장해달라는 요구사항이 추가된 상황을 생각해보자.
```java
//예제 1.4 회원 클래스에 연락처 필드 추가
public class Member {
    private String memberId;
    private String name;
    private String tel;     //추가!
    ···
}
```

- 등록 코드 변경<br/>
회원 객체에 tel이라는 필드를 추가해야 하고, 연락처 또한 저장될 수 있도록 INSERT SQL을 수정해야 한다.
이와 같이 연락처를 데이터베이스에 저장하려고 SQL과 JDBC API를 수정해야 한다.
<br/><br/>
- 조회 코드 변경<br/>
코드를 변경한 후에 회원 조회 화면을 수정해서 연락처 필드가 출력되게 할 때, 모든 연락처의 값이 null로 출력이 된다.
따라서 조회 SQL에 연락처 컬럼을 추가함으로써 화면에 연락처 값이 출력되게 할 수 있다.
<br/><br/>
- 수정 코드 변경<br/>
하지만 연락처가 수정되지 않는 버그를 발견할 수 있다. 자바 코드를 보면 MemberDAO.update(member) 메소드에 수정할 회원 정보와 연락처는 잘 전달이 된다.
MemberDAO를 열어서 UPDATE SQL을 확인해보니 TEL 컬럼을 추가하지 않아서 연락처가 수정되지 않는 것을 발견할 수 있다.
따라서 UPDATE SQL과 MemberDAO.update()의 일부 코드를 변경해서 연락처가 변경되도록 한다.<br/>
`list.add(member);  //등록`<br/>
`Member member = list.get(xxx)`     //조회<br/>
`member.setTel("xxx");  //수정`<br/><br/>

또한 회원은 어떤 한 팀에 필수로 소속되어야 한다는 요구사항이 추가되었다고 하자.
```java
//예제 1.5 회원 클래스에 연관된 팀 추가
public class Member {
    private String memberId;
    private String name;
    private String tel;
    private Team team;      //추가!
    ···
}

//추가된 팀
class Team {
    ···
    private String teamName;
    ···
}
```
다음 코드를 추가해서 화면에 팀의 이름을 출력할 수 있다.<br/>

`이름: member.getName();`<br/>
`소속 팀: member.getTeam().getTeamName();`     //추가

실제로 코드를 실행해보면, 데이터베이스를 확인해보면 모든 회원이 팀에 소속되어 있음에도 member.getTeam()의 값이 항상 null이다.
이유는 기존의 MemberDAO 클래스의 find()메소드를 통해 조회를 하기 때문인데, 이 find()메소드는 Team필드를 조회하도록 SQL이 작성되어 있지 않다.
이런 문제를 해결하기 위해서는 조회 SQL에서 JOIN을 사용함으로써 회원과 연관된 팀을 함께 조회해야 한다.<br/>

`SELECT M.member_id, M.name, M.tel, T.team_id, t.team_name`<br/>
`FROM MEMBER M`<br/>
`JOIN TEAM T ON M.team_id = T.team_id`<br/>

<br/>
SQL과 문제점을 정리해보면 Member 객체가 연관된 Team 객체를 사용할 수 있을지 없을지는 전적으로 사용하는 SQL에 달려있다는 것이다.
이 방식의 가장 큰 문제점은 데이터 접근 계층을 사용해서 SQL을 숨겨도 어쩔 수 없이 DAO를 열어서 어떤 SQL이 실행되는지 확인해야 한다는 점이다.(진정한 의미의 계층 분할이 아님)

<br/>
<b>엔티티</b>: 비즈니스 요구사항을 모델링한 객체 (ex. Member 혹은 Team)

지금처럼 SQL에 모든 것을 의존하는 상황에서는 개발자들이 엔티티를 신뢰하고 사용할 수 없다. 
이유는 강한 의존관계로 인해 회원을 조회할 때뿐만 아니라 회원 객체에 필드를 하나 추가할 때도 DAO의 CRUD 코드와 SQL 대부분을 변경해야 하기 때문이다.

<br/>
<b>애플리케이션이서 SQL을 직접 다룰 때 발생하는 문제점!</b>
- 진정한 의미의 계층 분할이 어렵다.
- 엔티티를 신뢰할 수 없다.
- SQL에 의존적인 개발을 피하기 어렵다.
<br/><br/>

### 1.1.3 JPA와 문제 해결
JPA를 사용하면 객체를 데이터베이스에 저장하고 관리할 때, 개발자가 직접 SQL을 작성하는 거시 아니라 JPA가 제공하는 API를 사용하면 된다.
그렇다면 JPA가 개발자 대신에 적절한 SQL을 생성해 데이터베이스에 전달한다.

<br/>
<b>▽저장 기능</b>

`jpa.persist(member);`   //저장 

persist() 메소드는 객체를 데이터베이스에 저장한다. 이 메소드를 호출하면 JPA가 객체와 매핑정보를 보고 적절한 INSERT SQL을 생성해서 데이터베이스에 전달한다.

<br/>
<b>▽조회 기능</b>

`String memberId = "id1";`<br/>
`Member member = jpa.find(Member.class, memberId);`   //조회

find() 메소드는 객체 하나를 데이터베이스에서 조회한다. JPA는 객체와 매핑정보를 보고 적절한 SELECT SQL을 생성해서 데이터베이스에 전달하고 그 결과로 Member 객체를 생성해서 반환한다.

<br/>
<b>▽수정 기능</b>

`Member member = jpa.find(Member.class, memberId);`<br/>
`member.setName("이름변경");`

JPA는 별도의 수정 메소드를 제공하지 않는다. 대신에 객체를 조회해서 값을 변경만 하면 트랜잭션을 커밋할 때 데이터베이스에 적절한 UPDATE SQL이 전달된다.

<br/>
<b>▽연관된 객체 조회</b>

`Member member = jpa.find(Member.class, memberId);`<br/>
`Team team = member.getTeam();`

JPA는 연관된 객체를 사용하는 시점에 적절한 SELECT SQL을 실행하기 때문에, JPA를 사용하면 연관된 객체를 마음껏 조회할 수 있다.

<br/><hr/><br/>


## 1.2 패러다임의 불일치
객체와 관계형 데이터베이스는 지향하는 목적이 서로 다르므로 둘의 기능과 표현 방법도 다르다. 
이것을 객체와 관계형 데이터베이스의 패러다임 불일치 문제라고 한다. 따라서 객체 구조를 테이블 구조에 저장하는 데에는 한계가 있다. 

애플리케이션은 객체지향 언어인 자바로 개발하고 데이터는 관계형 데이터베이스에 저장해야 한다면, 패러다임의 불일치 문제를 개발자가 중간에서 해결해야 한다.
문제는 이런 패러다임 불일치 문제를 해결하는데 너무나도 많은 시간과 코드를 소비해야 한다는 것이다.

지금부터 객체와 관계형 데이터베이스의 패러다임 차이 때문에 발생하는 다양한 문제를 살펴보고 JPA는 이러한 문제를 어떻게 해결하는지 알아보자.
<br/><br/>

### 1.2.1 상속
객체는 상속이라는 기능을 가지고 있지만 테이블은 상속이라는 기능이 없다. 
그나마 데이터베이스 모델링에서 이야기하는 슈퍼타입-서브타입 관계를 사용하면 객체 상속과 가장 유사한 형태로 테이블을 설계할 수 있다.

상속 관계의 2개의 객체가 있다고 할 때, JDBC API를 사용해서 객체를 저장할 시에는 부모 객체에서 부모 데이터만 꺼내서 INSERT SQL을 작성하고 자식 객체에서 자식 데이터만 꺼내서 INSERT SQL을 작성해야하는데, 코드량이 만만치 않다.
저장뿐만 아니라 조회도 쉽지 않다. 자식 객체를 조회하려면 테이블을 조인해서 조회한 결과로 객체를 생성해야 하기 때문이다.

이런 과정이 모두 패러다임의 불일치를 해결하고자 소모하는 비용이다.
하지만 만약 객체들을 데이터베이스가 아닌 자바 컬렉션에 보관한다면 부모 자식이나 타입에 대한 생각 없이 해당 컬렉션을 그냥 사용하면 된다. (저장 - add() 메소드 , 조회 - get() 메소드)

<br/>
<b>JPA</b>는 상속과 관련된 패러다임의 불일치 문제를 개발자 대신에 해결해준다. 따라서 개발자는 마치 자바 컬렉션에 객체를 저장하듯이 JPA에게 객체를 저장하면 된다.

객체를 저장할 때는 persist() 메소드를 사용해서 객체를 저장하면 된다. 
해당 메소드를 실행하면 JPA는 다음 SQL을 실행해서 객체를 부모와 자식 각각의 테이블에 나누어 저장한다.

객체를 조회할 때는 find() 메소드를 사용해서 객체를 조회하면 된다.
JPA는 이때 해당 두 테이블을 조인해서 필요한 데이터를 조회하고 결과를 반환해준다.
<br/><br/>

### 1.2.2 연관관계
<b>객체</b>는 <b>참조</b>를 사용해서 다른 객체와 연관관계를 가지고 <u><b>참조에 접근해서 연관된 객체를 조회</b></u>한다. 
반면에 <b>테이블</b>은 <b>외래 키</b>를 사용해서 다른 테이블과 연관관계를 가지고 <u><b>조인을 사용해서 연관된 테이블을 조회한다.</b></u>

참조를 사용하는 객체와 외래 키를 사용하는 관계형 데이터베이스 사이의 패러다임 불일치는 객체지향 모델링을 거의 포기하게 만들 정도로 극복하기 어렵다.

```java
class Member {
    Team team;
    ···
    Team getTeam() {
        return team;
    }
}

class Team {
    ···
}

member.getTeam();       //member -> team 접근
```
Member 객체는 Member의 team 필드에 Team 객체의 참조를 보관해서 Team 객체와 관계를 맺는다. 따라서 이 참조 필드에 접근하면 Member와 연관된 Team을 조회할 수 있다.

MEMBER 테이블은 team_id 외래 키 컬럼을 사용해서 TEAM 테이블과 관계를 맺는다. 이 외래 키를 사용해서 MEMBER 테이블과 TEAM 테이블을 조인하면 MEMBER 테이블과 연관된 TEAM 테이블을 조회할 수 있다.

객체는 참조가 있는 방향으로만 조회할 수 있다. 반면에 테이블은 외래 키 하나로 MEMBER JOIN TEAM도 가능하지만 TEAM JOIN MEMBER도 가능하다.

만약 객체를 테이블에 맞추어 모델링을 할 때, 객체 클래스에서 외래 키까지 관계형 데이터베이스가 사용하는 방식에 맞추면 객체와 연관된 객체를 참조를 통해서 조회할 수 없다. 
이런 방식을 따르면 좋은 객체 모델링은 기대하기 어렵고 결국 객체지향의 특성을 잃어버리게 된다.

반대로 객체지향 모델링을 사용하면 객체를 테이블에 저장하거나 조회하기가 쉽지 않다. 
객체를 필드로 연관관계를 맺고 테이블은 외래키로 연관관계를 맺기 때문인데, 객체 모델은 외래 키가 필요 없고 단지 참조만 있으면 된다. 
반면에 테이블은 참조가 필요 없고 외래 키만 있으면 된다. 결국, 개발자가 중간에서 변환 역할을 해야 한다.

<br/>
<b>▽저장</b>

객체를 데이터베이스에 저장하려면 참조를 위한 필드를 외래 키 값으로 변환해야 한다. 이때 외래 키 값을 찾아서 INSERT SQL을 만들어야 한다.

<br/>
<b>▽조회</b>

조회할 때는 외래 키 값을 객체의 필드 참조로 변환해서 객체에 보관해야 한다. 이때 SQL로 JOIN을 사용한다. SQL의 결과로 아래의 예제와 같이 객체를 생성하고 연관관계를 설정해서 반환하면 된다. 
``` java
//예제 1.10 개발자가 직접 연관관계 설정
public Member find(String memberId) {
    //SQL 실행
    ···
    Member member = new Member();
    ···
    
    //데이터베이스에서 조회한 회원 관련 정보를 모두 입력
    Team team = new Team();
    ···
    //데이터베이스에서 조회한 팀 관련 정보를 모두 입력
    
    //회원과 팀 관계 설정
    member.setTeam(team);
    return member;
}
```
이런 과정들은 모두 패러다임 불일치를 해결하려고 소모하는 비용이다. 만약 자바 컬렉션에 회원 객체를 저장한다면 이런 비용이 전혀 들지 않는다.

<br/>
<b>JPA</b>는 연관관계와 관련된 패러다임의 불일치 문제를 해결해준다. 다음 코드를 보자.

`member.setTeam(team);`<br/>
`jpa.persist(member);`

개발자는 회원과 팀의 관계를 설정하고 회원 객체를 저장하면 된다. 
JPA는 team의 참조를 외래키로 변환해서 적절한 INSERT SQL을 데이터베이스에 전달한다. 
또한 객체를 조회할 때 외래 키를 참조로 변환하는 일도 JPA가 처리한다.

`Member member = jpa.find(Member.class, memberId);`<br/>
`Team team = member.getTeam();`
<br/><br/>

### 1.2.3 객체 그래프 탐색
객체에서 회원이 소속된 팀을 조회할 때는 다음처럼 참조를 사용해서 연관된 팀을 찾으면 되는데, 이것을 <b>객체 그래프 탐색</b>이라고 한다.

`Team team = member.getTeam();`

객체는 마음껏 객체 그래프를 탐색할 수 있어야 한다. 그런데 이것이 실제로 가능할까?

<u>SQL을 직접 다루면 처음 실행하는 SQL에 따라 객체 그래프를 어디까지 탐색할 수 있는지 정해진다.</u> 이것은 객체지향 개발자에겐 너무나도 큰 제약이다. 
왜냐하면 비즈니스 로직에 따라 사용하는 객체 그래프가 다른데 언제 끊어질지 모를 객체 그래프를 함부로 탐색할 수 없기 때문이다. 

``` java
//예제 1.11 회원 조회 비즈니스 로직
class MemberService {
    ···
    public void process() {
        Member member = memberDAO.find(memberId);
        member.getTeam();   //객체 그래프 탐색이 가능한가?
        member.getOrder().getDelivery();    //??
    }
}
```
위의 코드를 보면 memberDAO를 통해 객체를 조회하지만, 이 객체와 연관된 Team, Order, Delivery 방향으로 객체 그래프를 탐색할 수 있을지 없을지는 이 코드만 보고는 전혀 예측할 수 없다. 
결국, 어디까지 객체 그래프 탐색이 가능한지 알아보려면 데이터 접근 계층을 열어서 SQL을 직접 확인해야 한다.
이것은 엔티티가 SQL에 논리적으로 종속되어서 발생하는 문제다. 그렇다고 연관된 모든 객체 그래프를 메모리에 올려두는 것은 현실성이 없다. 

<br/>
결론적으로 JPA를 사용하면 객체 그래프를 마음껏 탐색할 수 있다.

JPA는 연관된 객체를 신뢰하고 마음껏 조회할 수 있다. 이 기능은 실제 객체를 사용하는 시점까지 데이터베이스 조회를 미룬다고 해서 <b>지연 로딩</b>이라고 한다.

JPA는 지연 로딩을 투명<sub>transparent</sub>하게 처리한다.

이런 JPA는 연관된 객체를 즉시 함께 조회할지 아니면 실제 사용되는 시점에 지연해서 조회할지를 간단한 설정으로 정의할 수 있다. 
만약 즉시 조회하겠다고 설정하면 해당 객체를 조회할 때 JOIN을 사용한 SQL을 실행해서 연관된 객체 또한 함께 조회한다.
<br/><br/>

### 1.2.4 비교
데이터베이스는 기본 키의 값으로 각 로우<sub>row</sub>를 구분한다. 반면에 객체는 동일성<sub>identity</sub> 비교와 동등성<sub>equality</sub> 비교라는 두 가지 비교 방법이 있다.

- 동일성 비교는 == 비교이다. 객체 인스턴스의 주소 값을 비교한다.
- 동등성 비교는 equals() 메소드를 사용해서 객체 내부의 값을 비교한다.

따라서 테이블의 로우를 구분하는 방법과 객체를 구분하는 방법에는 차이가 있다.

```java
//예제 1.14 MemberDAO 코드
class MemberDAO {
    public Member getMember(String memberId) {
        String sql = "SELECT * FROM MEMBER WHERE member_id = ?";
        ···
        //JDBC API, SQL 실행
        return new Member(...);
    }
}
```
```java
//예제 1.15 MemberDAO 코드
String memberId = "100";
Member member1 = memberDAO.getMember(memberId);
Member member2 = memberDAO.getMember(memberId);

member1 != member2;     //다르다
```
위의 코드를 볼 때 member1과 member2의 동일성을 비교하면 false가 반환된다. 
그 이유는 member1과 member2는 같은 데이터베이스 로우에서 조회했지만, 객체 측면에서 볼 때 둘은 다른 인스턴스이기 때문이다.

따라서 데이터베이스의 같은 로우를 조회했지만 객체의 동일성 비교에는 실패한다. 만약 객체를 컬렉션에 보관했다면 동일성 비교에 성공했을 것이다. (get 메소드 사용)

<br/>
<b>JPA</b>는 같은 트랜잭션일 때 같은 객체가 조회되는 것을 보장한다. 그러므로 다음 코드에서 member1과 member2는 동일성 비교에 성공한다. 

`String memberId = "100";`<br/>
`Member member1 = jpa.find(Member.class, memberId);`<br/>
`Member member2 = jpa.find(Member.class, memberId);`

`member1 == member2;     //같다`

<br/>
정리를 해보자면, JPA는 패러다임의 불일치 문제를 해결해주고 정교한 객체 모델링을 유지하게 도와준다.

<br/><hr/><br/>


## 1.3 JPA란 무엇인가?
<b>JPA</b><sub>Java Persistence API</sub>는 자바 진영의 ORM 기술 표준이다. 

<b>ORM</b><sub>Object-Relational Mapping</sub>은 객체와 관계형 데이터베이스를 매핑한다는 뜻이다. 
ORM 프레임워크는 객체와 테이블을 매핑해서 패러다임의 불일치 문제를 개발자 대신 해결해준다.
예를 들어 ORM 프레임워크를 사용하면 객체를 데이터베이스에 저장할 때 INSERT SQL을 직접 작성하는 것이 아니라 객체를 마치 자바 컬렉션에 저장하듯이 ORM 프레임워크에 저장하면 된다.
그러면 ORM 프레임워크가 적절한 INSERT SQL을 생성해서 데이터베이스에 객체를 저장해준다. 

ORM 프레임워크는 단순히 SQL을 개발자 대신 생성해서 데이터베이스에 전달해주는 것뿐만 아니라 앞서 이야기한 다양한 패러다임의 불일치 문제들도 해결해준다.
따라서 객체 측면에서는 정교한 객체 모델링을 할 수 있으며 관계형 데이터베이스는 데이터베이스에 맞도록 모델링하면 된다.
그 후 둘의 매빙 방법만 ORM 프레임워크에 알려주면 된다. 

자바 진영에도 다양한 ORM 프레임워크들이 있는데 그중에 하이버네이트 프레임워크를 가장 많이 사용한다.
<br/><br/>

### 1.3.1 JPA 소개
<b>JPA는 자바 ORM 기술에 대한 API 표준 명세이다.</b> 쉽게 이야기하면 인터페이스를 모아둔 것이다. 
따라서 JPA를 사용하려면 JPA를 구현한 ORM 프레임워크를 선택해야 한다. 

JPA라는 표준 덕분에 특정 구현 기술에 대한 의존도를 줄일 수 있고 다른 구현 기술로 손쉽게 이동할 수 있는 장점이 있다.
<br/><br/>

### 1.3.2 왜 JPA를 사용해야 하는가?
JPA를 사용해야 하는 이유는 여러 가지이다. 

<br/>
<b>▽생산성</b>

JPA를 사용하면 자바 컬렉션에 객체를 저장하듯이 JPA에게 저장할 객체를 전달하면 된다. 
INSERT SQL을 작성하고 JDBC API를 사용하는 지루하고 반복적인 일은 JPA가 대신 처리해준다.(ex. persist(), find()) 

따라서 반복적인 코드와 CRUD용 SQL을 개발자가 직접 작성하지 않아도 되며, DDL 문을 자동으로 생성해주는 기능도 있다. 
이런 기능들을 사용하면 데이터베이스 설계 중심의 패러다임을 객체 설계 중심으로 역전시킬 수 있다.

<br/>
<b>▽유지보수</b>

JPA를 사용하면 필드를 추가하거나 삭제해도 수정해야 할 코드가 줄어든다. 
따라서 개발자가 작성해야 했던 SQL과 JDBC API 코드를 JPA가 대신 처리해주므로 유지보수해야 하는 코드 수가 줄어든다.
또한 JPA가 패러다임의 불일치 문제를 해결해주므로 객체지향 언어가 가진 장점들을 활용해서 유연하고 유지보수하기 좋은 도메인 모델을 편리하게 설계할 수 있다.

<br/>
<b>▽패러다임의 불일치 해결</b>

JPA는 상속, 연관관계, 객체 그래프 탐색, 비교하기와 같은 패러다임의 불일치 문제를 해결해준다.

<br/>
<b>▽성능</b>

JPA는 애플리케이션과 데이터베이스 사이에서 다양한 성능 최적화 기회를 제공한다.
JPA는 애플리케이션과 데이터베이스 사이에서 동작하기 때문에, 이렇게 애플리케이션과 데이터베이스 사이에 계층이 하나 더 있으면 최적화 관점에서 시도해 볼 수 있는 것들이 많다. 

예를 들어 JPA를 사용하면 회원을 조회하는 SELECT SQL을 한 번만 데이터베이스에 전달하고 두 번째는 조회한 회원 객체를 재사용할 수 있다는 것이다.

<br/>
<b>▽데이터 접근 추상화와 벤더 독립성</b>

관계형 데이터베이스는 같은 기능도 벤더마다 사용법이 다른 경우가 많다. 결국, 애플리케이션은 처음 선택한 데이터베이스 기술에 종속되고 다른 데이터베이스로 변경하기는 매우 어렵다. 

하지만 JPA는 애플리케이션과 데이터베이스 사이에 추상화된 데이터 접근 계층을 제공해서 애플리케이션이 특정 데이터베이스 기술에 종속되지 않도록 한다. 
만약 데이터베이스를 변경하면 JPA에게 다른 데이터베이스를 사용한다고 알려주기만 하면 된다.

<br/>
<b>▽표준</b>

JPA는 자바 진영의 ORM 기술 표준이다. 이러한 표준을 사용하면 다른 구현 기술로 손쉽게 변경할 수 있다.

<br/><hr/><br/><br/>
다음 포스트는 '자바 ORM 표준 JPA 프로그래밍' 책의 Chapter 2. JPA 시작에 대한 글입니다. 감사합니다:)
