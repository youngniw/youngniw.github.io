---
layout: post
title: "[알고리즘] 해시 테이블 정리"
categories: Algorithm
tags: [Algorithm, HashTable, 알고리즘, 해시테이블]
---

## 0. 들어가기에 앞서..

이번 포스트에서는 해시 테이블에 대해 설명하고자 합니다.

<br/>
<hr/>

## 1. 해시 테이블

해시 테이블: 저장된 원소의 개수에 관계없이 상수 시간 검색을 가능하게 하는 검색 효율의 극단을 추구하는 자료 구조

<img src="https://user-images.githubusercontent.com/78736070/213623196-de5578e7-5e0d-48f5-9c23-7559396c9863.png" height="450px" />

<b>[ 해시 테이블에 원소 저장 방법 ]</b>

1. 해당 원소를 해시 함수에 적용하여 해시 값을 계산
2. 해시 값을 주소로 하여 해시 테이블에 원소를 저장

즉, 해시 테이블은 원소를 저장할 위치를 **해시 함수**를 이용하여 상수 시간 만에 계산할 수 있다.

<br/>

> 적재율<sup>Load Factor</sup>: 해시 테이블에 원소가 차 있는 비율

그렇기 때문에 적재율은 해시 테이블의 성능에 영향을 미치게 된다.

<br/>

만약 해시 함수를 이용하여 해시 값을 구했을 때, 해당 해시 값의 자리에 이미 원소가 존재하는 경우에는 어떻게 해야 할까?

> 충돌<sup>Collision</sup>: 해시 테이블의 해시 값이 가리키는 자리에 이미 원소가 들어가 있는 경우

이런 상황이 발생했을 때를 위해 **충돌 처리**를 해야 한다.

> 참고. 해시 테이블과 검색 트리 비교
>
> |개념|설명|
> |--|--|
> |해시 테이블|원소가 저장될 자리가 **원소의 값**에 의해 결정되는 자료 구조|
> |검색 트리|원소가 저장될 자리가 이미 트리에 **존재하는 원소와 비교**하여 결정되는 자료 구조|

<br/>
<hr/>

## 2. 해시 함수

해시 함수: 키(원소) 값을 입력으로 받아 해시 테이블 상의 주소 반환

<b>[ 해시 함수의 성질 ]</b>

- 입력 원소가 해시 테이블에 고루 저장되도록 해야 함(충돌 확률을 줄이기 위해)
- 계산이 간단해야 함

<br/>

### 2.1 나누기 방법

위의 이미지에서 사용한 방법은 나누기 방법이다.

나누기 방법: 테이블 크기에 대한 나머지 연산을 사용하여 해시 값을 결정

해시 함수: `h(x) = x mod m`<br/>
(m : 해시 테이블의 크기)

해시 테이블은 0부터 m-1까지의 주소값을 가지기 때문에 m으로 나머지 연산을 사용한다.

이때 m은 2의 멱수에 가깝지 않은 소수를 택하는 것이 좋다.

<br/>


### 2.2 곱하기 방법

곱하기 방법: 입력 값을 0과 1 사이의 소수로 대응시킨 후에 해시 테이블 크기 m을 곱하여 0부터 m-1 사이로 팽창

해시 함수: `h(x) = ⌊ m(xA mod 1) ⌋`<br/>
(m : 해시 테이블의 크기, A는 0 < A < 1 범위의 상수)

1. x에 A를 곱한 다음 소수부만 취함
2. 소수부에 m을 곱하여 그 정수부의 값이 해시 값

![2.2 곱하기 방법 이미지](https://user-images.githubusercontent.com/78736070/213618757-c10bd130-f43e-44fb-9531-1e73be1a33b7.png)

곱하기 방법은 나누기 방법과 달리 해시 테이블의 크기 m을 어떤 값으로 설정해도 상관없다.

<br/>

다음의 표는 나누기 방법과 곱하기 방법의 차이를 보여준다.

|해시 함수|설명|
|--|--|
|나누기 방법|해시 테이블 크기보다 큰 수를 해시 테이블 크기 범위에 들어오도록 수축|
|곱하기 방법|0과 1 사이의 소수 값으로 수축 후에 해시 테이블 크기만큼 곱하여 팽창|

<br/>
<hr/>

## 3. 충돌 해결

충돌: 해시 테이블 내의 한 주소를 놓고 2개 이상의 원소가 자리를 다투는 것

충돌 해결에는 2가지 방법이 있다.

1. 체이닝
2. 개방 주소 방법

<br/>

### 3.1 체이닝

체이닝<sup>Chaining</sup>: 같은 주소로 해싱 되는 원소를 모두 하나의 연결 리스트에 매달아 관리하는 방법

즉, 해시 테이블의 크기가 m이라면 최대 m 개의 연결 리스트가 존재할 수 있다.

<img src="https://user-images.githubusercontent.com/78736070/213623947-bc2f3f0c-35c6-46f5-9681-cd6ef4f54c5b.png" height="500px" />

<u>체이닝은 따라서 적재율이 1을 넘어도 사용할 수 있다.</u>

<b>[ 원소 삽입 ]</b>

원소를 삽입하기 위해서는 해시 값에 해당하는 연결 리스트의 맨 앞에 삽입한다.

맨 앞에 삽입하는 이유는 효율성 때문이다.


<b>[ 원소 검색 ]</b>

원소를 검색할 때에는 해시 값에 해당하는 연결 리스트의 원소들을 차례대로 순회하여 찾는다.


<b>[ 원소 삭제 ]</b>

원소를 삭제 시에는 검색과 동일한 방법으로 원소를 찾아 해당 원소를 삭제한다.

<br/>


### 3.2 개방 주소 방법

개방 주소<sup>Open Addressing</sup> 방법: 체이닝과 달리 추가 공간을 허용하지 않으며, 충돌이 일어나더라도 주어진 테이블 공간 내에서 해결

즉, 개방 주소 방법은 모든 원소가 반드시 자신의 해시 값과 일치하는 주소에 저장되지는 않는다.

<u>개방 주소 방법은 테이블에 주어진 공간만 사용할 수 있으므로 적재율이 1을 넘을 수 없다.</u>

<b>[ 원소 삽입 ]</b>

1. 해시 함수를 계산하여 해시 값 도출
2. 계산된 해시 값의 주소를 차지하는 다른 원소가 없을 시 원소를 그 자리에 삽입
3. 해당 자리에 원소가 있을 경우, 정해진 규칙에 따라 다음 자리를 찾고 빈 자리가 발견되면 해당 자리에 삽입

즉, 빈자리를 찾을 때까지 순차적으로 해시 함수를 적용한다.

<b>[ 원소 삭제 ]</b>

중간에 있는 원소를 삭제할 때에는 원소 검색 시에 빈자리가 발견되어 원소를 발견하지 못하는 경우가 발생할 수 있다.

따라서 이 경우에는 원소를 삭제할 때에 삭제된 자리라는 것을 표시하여 이후의 검색 시에 문제 발생을 예방하면 된다.

<br/>

첫 해시 값 이후 다음 주소를 결정하는 방법 중 3가지를 소개하고자 한다.

#### 3.2.1 선형 조사

선형 조사: 가장 간단한 방법으로, 충돌이 일어난 바로 다음 자리(주소)를 확인

![3.2.1 선형 조사 이미지](https://user-images.githubusercontent.com/78736070/213630020-ac334663-eff5-48db-91b9-322d50bf3c67.png)

i 번째 해시 함수: h<sub>j</sub>(x) = (h(x) + i) mod m<br/>
(i = 0, 1, 2, ...)

즉, 빈자리를 찾을 때까지 1번째, 2번째, 3번째 순서로 해시 함수를 적용한다.

선형 조사의 경우 1차 군집이 발생할 수 있다.

> 1차 군집<sup>Primary Clustering</sup>: 특정 영역에 원소가 몰려 치명적으로 성능이 떨어지는 현상

영역이 커질수록 해당 영역으로 해싱 될 확률이 높아져 다른 영역에 비해 크기가 빨리 커진다.

<br/>

#### 3.2.2 이차원 조사

이차원 조사: 바로 뒷자리를 확인하는 것이 아닌, 보폭을 이차 함수로 넓혀가면서 확인

![3.2.2 이차원 조사 이미지](https://user-images.githubusercontent.com/78736070/213630031-59e5b577-b5f8-4e44-8238-d8c11dbec8d3.png)

i번째 해시 함수: h<sub>j</sub>(x) = (h(x) + c<sub>1</sub> * i<sup>2</sup> + c<sub>2</sub> * i) mod m<br/>
(i = 0, 1, 2, ...)

이차원 조사를 사용하면 특정 영역에 원소가 몰려도 그 영역을 빠르게 벗어날 수 있다.

하지만 이차원 조사의 경우 2차 군집이 발생할 수 있다.

> 2차 군집<sup>Secondary Clustering</sup>: 여러 개의 원소가 동일한 초기 해시 값을 갖게 되어 모두 같은 순서로 조사를 하게 됨으로써 비효율적이 되는 현상

조사 보폭은 이차 함수로 인해 넓어지지만 최초의 해시 값이 같은 경우에는 2차 군집으로 인해 이득을 보지 못한다.

<br/>

#### 3.2.3 더블 해싱

더블 해싱: 2개의 서로 다른 해시 함수를 사용하여 해싱 값을 구함

i 번째 해시 함수: h<sub>j</sub>(x) = (h(x) + i*f(x)) mod m<br/>
(i = 0, 1, 2, ...)

즉, 충돌이 생겨 다음 볼 주소를 계산할 경우에 두 번째 해시 함숫값만큼 이동하여 조사하게 된다.

1차 군집과 2차 군집 문제는 따라서 발생하지 않게 된다.

더블 해싱의 경우, 2개의 해시 함수를 정할 때 권장하는 방법
- h(x) = x mod m
- f(x) = 1 + (x mod m')  (이때, m'는 m보다 조금 작은 소수)

더블 해싱에서는 두 번째 해시 함숫값 f(x)가 해시 테이블 크기 m과 서로소인 값이어야 한다. 따라서 테이블 크기인 m을 소수로 잡고, f(x)의 값이 항상 m보다 작은 자연수가 되도록 하면 된다.

<br/>
<hr/>

지금까지 해시 테이블에 대해 설명하였습니다.

감사합니다:)
